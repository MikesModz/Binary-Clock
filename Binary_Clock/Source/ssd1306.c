/****************************************************************************
* ssd1306.c
*
* SSD1306 OLED display driver for Atmel AVR micro controllers.
*
*   Copyright (C) 2015 Michael Williamson. All rights reserved.
*   Authors: Michael Williamson <mikesmodz@gmail.com>
*
* Redistribution and use in source and binary forms, with or without
* modification, are permitted provided that the following conditions
* are met:
*
* 1. Redistributions of source code must retain the above copyright
*    notice, this list of conditions and the following disclaimer.
* 2. Redistributions in binary form must reproduce the above copyright
*    notice, this list of conditions and the following disclaimer in
*    the documentation and/or other materials provided with the
*    distribution.
*
* THIS SOFTWARE IS PROVIDED BY THE COPYRIGHT HOLDERS AND CONTRIBUTORS
* "AS IS" AND ANY EXPRESS OR IMPLIED WARRANTIES, INCLUDING, BUT NOT
* LIMITED TO, THE IMPLIED WARRANTIES OF MERCHANTABILITY AND FITNESS
* FOR A PARTICULAR PURPOSE ARE DISCLAIMED. IN NO EVENT SHALL THE
* COPYRIGHT OWNER OR CONTRIBUTORS BE LIABLE FOR ANY DIRECT, INDIRECT,
* INCIDENTAL, SPECIAL, EXEMPLARY, OR CONSEQUENTIAL DAMAGES (INCLUDING,
* BUT NOT LIMITED TO, PROCUREMENT OF SUBSTITUTE GOODS OR SERVICES; LOSS
* OF USE, DATA, OR PROFITS; OR BUSINESS INTERRUPTION) HOWEVER CAUSED
* AND ON ANY THEORY OF LIABILITY, WHETHER IN CONTRACT, STRICT
* LIABILITY, OR TORT (INCLUDING NEGLIGENCE OR OTHERWISE) ARISING IN
* ANY WAY OUT OF THE USE OF THIS SOFTWARE, EVEN IF ADVISED OF THE
* POSSIBILITY OF SUCH DAMAGE.
*
****************************************************************************/

/****************************************************************************
* Included Files
****************************************************************************/
#include <avr/io.h>
#include <avr/interrupt.h>
#include <string.h>
#include <util/delay.h>
#include "avrlibtypes.h"
#include "ssd1306.h"
#include "twi.h"

/* Include display initialization sequence */
#if defined SSD1306_128_32
#include "SSD1306_128_32_init.h"
#endif

#if defined SSD1306_128_64
#include "SSD1306_128_64_init.h"
#endif

#if defined SSD1306_96_16
#include "SSD1306_96_16_init.h"
#endif

/****************************************************************************
* Private Function Prototypes
****************************************************************************/
static u08 SSD1306_Command(u08 Command);
static void SSD1306_InitDisplay(const u08 *InitTable);

/****************************************************************************
* Private Data
****************************************************************************/

/* Frame buffer for display */
static u08 SSD1306_Buffer[SSD1306_LCD_HEIGHT*SSD1306_LCD_WIDTH/8] =
{
	0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00,
	0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00,
	0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00,
	0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00,
	0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00,
	0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00,
	0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00,
	0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00,
	0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00,
	0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00,
	0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00,
	0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00,
	0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00,
	0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00,
	0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00,
	0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00,
	0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00,
	0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00,
	0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00,
	0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00,
	0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00,
	0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00,
	0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00,
	0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00,
	#if( SSD1306_LCD_HEIGHT * SSD1306_LCD_WIDTH > 96*16)
	0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00,
	0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00,
	0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00,
	0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00,
	0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00,
	0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00,
	0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00,
	0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00,
	0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00,
	0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00,
	0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00,
	0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00,
	0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00,
	0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00,
	0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00,
	0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00,
	0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00,
	0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00,
	0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00,
	0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00,
	0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00,
	0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00,
	0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00,
	0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00,
	0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00,
	0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00,
	0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00,
	0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00,
	0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00,
	0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00,
	0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00,
	0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00,
	0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00,
	0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00,
	0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00,
	0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00,
	0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00,
	0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00,
	0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00,
	0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00,
	#if (SSD1306_LCD_HEIGHT == 64)
	0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00,
	0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00,
	0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00,
	0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00,
	0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00,
	0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00,
	0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00,
	0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00,
	0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00,
	0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00,
	0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00,
	0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00,
	0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00,
	0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00,
	0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00,
	0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00,
	0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00,
	0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00,
	0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00,
	0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00,
	0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00,
	0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00,
	0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00,
	0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00,
	0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00,
	0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00,
	0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00,
	0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00,
	0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00,
	0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00,
	0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00,
	0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00,
	0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00,
	0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00,
	0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00,
	0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00,
	0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00,
	0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00,
	0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00,
	0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00,
	0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00,
	0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00,
	0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00,
	0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00,
	0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00,
	0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00,
	0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00,
	0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00,
	0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00,
	0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00,
	0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00,
	0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00,
	0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00,
	0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00,
	0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00,
	0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00,
	0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00,
	0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00,
	0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00,
	0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00,
	0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00,
	0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00,
	0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00,
	0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00,
	#endif
	#endif
};

/****************************************************************************
* Private Functions
****************************************************************************/

/****************************************************************************
* Name: SSD1306_InitDisplay
*
* Description:
* 	Sends the display initialisation sequence.
*
* Input Parameters:
* 	*InitTable = Pointer to display initialisation table.
*
* Returned Value:
*	Nothing.
*
* Assumptions/Limitations:
*	Does not check the status of the write.
****************************************************************************/
static void SSD1306_InitDisplay(const u08 *InitTable)
{
	u08 commands = 0;

	/* Get number of commands in table */
	commands = *InitTable++;

	/* Send commands */
	while (commands--)
	{
		/* Send command */
		SSD1306_Command(*InitTable++);
	}
}

/****************************************************************************
* Name: SSD1306_Command
*
* Description:
* 	Sends a command byte to the display.
*
* Input Parameters:
* 	Command = Command to send.
*
* Returned Value:
*	Success = TRUE Failure = FALSE.
*
* Assumptions/Limitations:
*	None.
****************************************************************************/
static u08 SSD1306_Command(u08 Command)
{
	u08 buffer[2] = { 0 };

	buffer[0] = 0x00;
	buffer[1] = Command;
	if (TWI_WriteTo(SSD1306_DEVICE_ADDRESS, buffer, 2, TRUE, TRUE))
	{
		return FALSE;
	}
	return TRUE;
}

/****************************************************************************
* Public Functions
****************************************************************************/

/****************************************************************************
* Name: SSD1306_Init
*
* Description:
* 	Initialises the display.
*
* Input Parameters:
* 	None.
*
* Returned Value:
*	Nothing.
*
* Assumptions/Limitations:
*	Assumes the TWI interface has been initialised.
****************************************************************************/
void SSD1306_Init(void)
{
	/* Send initialization sequence */
#if defined SSD1306_128_32
	SSD1306_InitDisplay(SSD1306_128_32_Init);
#endif

#if defined SSD1306_128_64
	SSD1306_InitDisplay(SSD1306_128_64_Init);
#endif

#if defined SSD1306_96_16
	SSD1306_InitDisplay(SSD1306_96_16_Init);
#endif
}

/****************************************************************************
* Name: SSD1306_UpdateDisplay
*
* Description:
* 	Copies the contents of the frame buffer to the display.
*
* Input Parameters:
* 	None.
*
* Returned Value:
*	Nothing.
*
* Assumptions/Limitations:
*	Does not check the status of the write.
****************************************************************************/
void SSD1306_UpdateDisplay(void)
{
	u16 i = 0;
	u08 x = 0;
	u08 buffer[20] = { 0 };
	u08 index = 0;

	SSD1306_Command(SSD1306_COLUMNADDR);
	SSD1306_Command(0);
	SSD1306_Command(SSD1306_LCD_WIDTH - 1);
	SSD1306_Command(SSD1306_PAGEADDR);
	SSD1306_Command(0);

#if SSD1306_LCD_HEIGHT == 64
	SSD1306_Command(7);
#endif

#if SSD1306_LCD_HEIGHT == 32
	SSD1306_Command(3);
#endif

#if SSD1306_LCD_HEIGHT == 16
	SSD1306_Command(1);
#endif

	for (i = 0; i < (SSD1306_LCD_WIDTH * SSD1306_LCD_HEIGHT / 8); i++)
	{
		index = 0;
		buffer[index++] = 0x40;
		for (x = 0; x < 16; x++)
		{
			buffer[index++] = SSD1306_Buffer[i++];
		}
		i--;
		TWI_WriteTo(SSD1306_DEVICE_ADDRESS, buffer, index, TRUE, TRUE);
	}
}

/****************************************************************************
* Name: SSD1306_InvertDisplay
*
* Description:
* 	Inverts the display.
*
* Input Parameters:
* 	Invert = TRUE or FALSE.
*
* Returned Value:
*	Nothing.
*
* Assumptions/Limitations:
*	Does not check the status of the write.
****************************************************************************/
void SSD1306_InvertDisplay(u08 Invert)
{
	if (Invert)
	{
		SSD1306_Command(SSD1306_INVERTDISPLAY);
	}
	else
	{
		SSD1306_Command(SSD1306_NORMALDISPLAY);
	}
}

/****************************************************************************
* Name: SSD1306_DimDisplay
*
* Description:
* 	Dims the display.
*
* Input Parameters:
* 	Dim = TRUE or FALSE.
*
* Returned Value:
*	Nothing.
*
* Assumptions/Limitations:
*	Does not check the status of the write.
****************************************************************************/
void SSD1306_DimDisplay(u08 Dim)
{
	u08 contrast = 0;

	if (Dim)
	{
		contrast = 0x00;
	}
	else
	{
		contrast = 0xCF;
	}
	SSD1306_Command(SSD1306_SETCONTRAST);
	SSD1306_Command(contrast);
}

/****************************************************************************
* Name: SSD1306_ScrollRight
*
* Description:
* 	Starts the display scrolling right.
*
* Input Parameters:
* 	Start = Row start.
*	Stop = Row end.
*
* Returned Value:
*	Nothing.
*
* Assumptions/Limitations:
*	Does not check the status of the write.
****************************************************************************/
void SSD1306_ScrollRight(u08 Start, u08 Stop)
{
	SSD1306_Command(SSD1306_RIGHT_HORIZONTAL_SCROLL);
	SSD1306_Command(0X00);
	SSD1306_Command(Start);
	SSD1306_Command(0X00);
	SSD1306_Command(Stop);
	SSD1306_Command(0X00);
	SSD1306_Command(0XFF);
	SSD1306_Command(SSD1306_ACTIVATE_SCROLL);
}

/****************************************************************************
* Name: SSD1306_ScrollLeft
*
* Description:
* 	Starts the display scrolling right.
*
* Input Parameters:
* 	Start = Row start.
*	Stop = Row end.
*
* Returned Value:
*	Nothing.
*
* Assumptions/Limitations:
*	Does not check the status of the write.
****************************************************************************/
void SSD1306_ScrollLeft(u08 Start, u08 Stop)
{
	SSD1306_Command(SSD1306_LEFT_HORIZONTAL_SCROLL);
	SSD1306_Command(0X00);
	SSD1306_Command(Start);
	SSD1306_Command(0X00);
	SSD1306_Command(Stop);
	SSD1306_Command(0X00);
	SSD1306_Command(0XFF);
	SSD1306_Command(SSD1306_ACTIVATE_SCROLL);
}

/****************************************************************************
* Name: SSD1306_ScrollDiagRight
*
* Description:
* 	Starts the display scrolling right.
*
* Input Parameters:
* 	Start = Row start.
*	Stop = Row end.
*
* Returned Value:
*	Nothing.
*
* Assumptions/Limitations:
*	Does not check the status of the write.
****************************************************************************/
void SSD1306_ScrollDiagRight(u08 Start, u08 Stop)
{
	SSD1306_Command(SSD1306_SET_VERTICAL_SCROLL_AREA);
	SSD1306_Command(0X00);
	SSD1306_Command(SSD1306_LCD_HEIGHT);
	SSD1306_Command(SSD1306_VERTICAL_AND_RIGHT_HORIZONTAL_SCROLL);
	SSD1306_Command(0X00);
	SSD1306_Command(Start);
	SSD1306_Command(0X00);
	SSD1306_Command(Stop);
	SSD1306_Command(0X01);
	SSD1306_Command(SSD1306_ACTIVATE_SCROLL);
}

/****************************************************************************
* Name: SSD1306_ScrollDiagLeft
*
* Description:
* 	Starts the display scrolling right.
*
* Input Parameters:
* 	Start = Row start.
*	Stop = Row end.
*
* Returned Value:
*	Nothing.
*
* Assumptions/Limitations:
*	Does not check the status of the write.
****************************************************************************/
void SSD1306_ScrollDiagLeft(u08 Start, u08 Stop)
{
	SSD1306_Command(SSD1306_SET_VERTICAL_SCROLL_AREA);
	SSD1306_Command(0X00);
	SSD1306_Command(SSD1306_LCD_HEIGHT);
	SSD1306_Command(SSD1306_VERTICAL_AND_LEFT_HORIZONTAL_SCROLL);
	SSD1306_Command(0X00);
	SSD1306_Command(Start);
	SSD1306_Command(0X00);
	SSD1306_Command(Stop);
	SSD1306_Command(0X01);
	SSD1306_Command(SSD1306_ACTIVATE_SCROLL);
}

/****************************************************************************
* Name: SSD1306_StopScroll
*
* Description:
* 	Stops the display from scrolling..
*
* Input Parameters:
* 	None.
*
* Returned Value:
*	Nothing.
*
* Assumptions/Limitations:
*	Does not check the status of the write.
****************************************************************************/
void SSD1306_StopScroll(void)
{
	SSD1306_Command(SSD1306_DEACTIVATE_SCROLL);
}

/****************************************************************************
* Name: SSD1306_ClearDisplay
*
* Description:
* 	Clears the display frame buffer.
*
* Input Parameters:
* 	None.
*
* Returned Value:
*	Nothing.
*
* Assumptions/Limitations:
*	None.
****************************************************************************/
void SSD1306_ClearDisplay(void)
{
	memset(SSD1306_Buffer, 0, (SSD1306_LCD_WIDTH * SSD1306_LCD_HEIGHT / 8));
}

/****************************************************************************
* Name: SSD1306_DrawPixel
*
* Description:
* 	Draws a single pixel on the display.
*
* Input Parameters:
* 	X = Horizontal coordinate.
*	Y = Vertical coordinate.
*	Colour = SSD1306_COL_WHITE, SSD1306_COL_BLACK or SSD1306_COL_INVERSE
*
* Returned Value:
*	Nothing.
*
* Assumptions/Limitations:
*	None.
****************************************************************************/
void SSD1306_DrawPixel(s16 X, s16 Y, u16 Colour)
{
	if ( (X < 0) || (X >= SSD1306_LCD_WIDTH) || (Y < 0)
	  || (Y >= SSD1306_LCD_HEIGHT))
	{
		return;
	}

	switch (Colour)
	{
		case SSD1306_COL_WHITE:
			SSD1306_Buffer[X + (Y / 8) * SSD1306_LCD_WIDTH] |= (1 << (Y & 7));
			break;
		case SSD1306_COL_BLACK:
			SSD1306_Buffer[X + (Y / 8) * SSD1306_LCD_WIDTH] &= ~(1 << (Y & 7));
			break;
		case SSD1306_COL_INVERSE:
			SSD1306_Buffer[X + (Y / 8) * SSD1306_LCD_WIDTH] ^= (1 << (Y & 7));
			break;
	}
}

